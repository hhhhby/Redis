# 索引

 - 定义：一种（帮助存储引擎快速获取数据的）**数据结构**
 - 使用索引可以提高查询速度，但
   - 1.需要占用物理空间，数量越大，占的越多
   - 2.创建索引和维护索引需要耗费时间，这种时间随着数据量的增加而增大
   - 3.会降低表的增删改的效率，每次增删改索引，B+树都需要进行动态维护
## 使用索引的情况
   - 字段有**唯一性限制**的，比如商品编码
   - 经常用于**WHERE查询条件**的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
   - 经常用于**GRUOUP BY和ORDER BY**的字段，这样在查询的时候就不需要再去做一次排序了。因为建立索引之后在 B+Tree 中的记录都是排序好的
## 不适用索引的情况
   - WHERE 条件，GROUP BY，ORDER BY 里用不到的字段，**索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的**。
   - 字段中存在**大量重复数据**，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
   - **表数据较少**
   - **经常更新的字段**，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

## 分类：
   - 按**数据结构**分类：B+tree索引、Hash索引、Full-text索引
     - InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，**B+Tree** 索引类型也是 MySQL 存储引擎采用最多的索引类型。
     - B+Tree 相比于 B 树和二叉树来说，最大的优势在于**查询效率很高**，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 **3-4次**。
     - 二级索引（非主键）需要查**两个B+Tree**才能查到数据
       - eg：select * from product where product_no = '0002';其中product_no不是主键，主键是id，这个就是二级索引
       - 二级索引的B+Tree的叶子放的是对应主键的值，即上述语句会首先找product_no = '0002'对应的id值（一次B+Tree），然后再根据id返回一行数据（又一次B+Tree），这个过程也叫做**回表**。
       - 但是，如果上述要查询的不是整行数据（*），而是id，就查一次。
     <img width="739" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/abd503cc-b7d4-450a-9e06-d33f9ab8131d">
     
   
   - 按**物理存储**分类：聚簇索引（主键索引）、二级索引（辅助索引）
   - 按**字段特性**分类：主键索引、唯一索引、普通索引、前缀索引
     - 主键索引**不能为空**，一张表只能有**一个**主键索引
     - 唯一索引的**值必须唯一**，一张表可以有**多个**主键索引
     - 普通索引就是建立在普通字段上的索引，**不要求是否为空，也不要求值必须唯一**
     - 前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上，使用前缀索引的目的是为了**减少索引占用的存储空间，提升查询效率**。
   - 按**字段个数**分类：单列索引、联合索引
     - 单列索引：建立在**单列**上的索引
     - 联合索引：建立在**多列**上的索引
       - 必须遵循最左匹配原则
     - 索引下推：
## B+Tree和B Tree
   - B+Tree只在叶子结点存储数据，B-Tree非叶子节点也存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点
   - B+Tree 叶子节点采用的是**双链表连接**，适合 MySQL 中常见的**基于范围的顺序查找**，而 B-Tree无法做到这一点
## B+Tree和二叉树
   - B+Tree在处理**大规模数据和磁盘存储**时具有明显的优势（树较矮），**O(logdN)**
   - 二叉树适合处理**较小数据量（内存）** ，**O(logN)**
## B+Tree vs Hash
   - Hash 在做**等值查询**的时候效率贼快，搜索复杂度为 **O(1)**，但是**不适合做范围查询**
   - 
## 优化索引的方法

 - 前缀索引优化
   - 使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小
   - 不能使用前缀索引的情况
     - 1.order by 就无法使用前缀索引；
     - 2.无法把前缀索引用作覆盖索引；
 - 覆盖索引优化
   - 可以直接从二级索引中查询得到记录，避免回表的操作
   
 - 主键索引最好自增
   - InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。
 - 索引最好设置为NOT NULL
   - 索引列存在NULL值会导致优化器在做索引选择的时候更加复杂，更加难以优化
   - NULL是一个没有意义的值，但是它会**占用物理空间**，所以会带来存储空间的问题 
 - 防止索引失效


## 数据页
 - InnoDB是以**数据页**为单位进行读写数据的
 - 
