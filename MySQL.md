# 基础

 ## 关系型数据库
 - 建立在关系模型基础上，有多张相互连接的**二维表**组成的数据库。
 - 特点
   - 使用**表**存储数据，格式统一，便于维护
   - 使用**SQL语言**操作，标准统一，使用方便
 ## SQL分类
 - DDL：数据**定义**语言（**定义数据库对象**）
   - 数据库操作
     - `` select database(); #查询当前数据库``
   - 表操作
     - `` show tables;``
     - `` desc 表名;``
     - `` show create table 表名;``
   - 数据类型
     - 数值类型
     <img width="1325" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/dd50b581-a4a9-45fd-94e8-b63c59224922">

     - 字符串类型
    <img width="838" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/950ecf94-22c7-49c5-b840-428a6ff4b2be">
     
     - 日期时间类型
      <img width="962" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/903cdd5d-9d11-4e0a-9a46-1ccdbdf056a5">
      
   - 表操作-修改
     - **添加字段**：`` alter table 表名 add 字段名 类型（长度）[comment 注释] [约束];``
     - **修改数据类型** `` alter table 表名 modify 字段名 新数据类型(长度);``
     - **修改字段名和字段类型** ``alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];``
     - **删除字段** `` alter table 表名 drop 字段名;``
     - **修改表名** `` alter table rename to 新表名;``
   - 表操作-删除
     - 删除表 `` drop table 表名;``
     - 删除指定表，并重新创建该表 `` truncate table 表名;``
 - DML：数据**操作**语言（**对数据库表中的数据进行增删改**）
   - 添加数据
   - 修改数据
   - 删除数据
 - DQL：数据**查询**语言（**查询数据库中表的记录**）
   - 基本查询
     - 查询多个字段：`` select 字段1，字段2，...，字段n from 表名;``
     - 设置别名：`` select 字段 as '别名' from 表名;``
     - 去除重复记录：`` select distinct 字段列表 from 表名;``
   - 条件查询
     - `` select 字段列表 from 表名 where 条件列表;``
   - 聚合函数
     - count：计算数量
     - avg：计算平均值
     - max：计算最大值
     - min：计算最小值
     - sum：计算和
     - `` select count/avg/max/min/sum(字段) from 表名;``
   - 分组查询
     - group by：`` select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件]``
     - where 与 having 区别
       - 执行时机不同：where是分组之前进行过滤，having是分组之后进行过滤
       - 判断条件不同：where不能对聚合函数进行判断，having可以
   - 排序查询
     - order by：`` select 字段列表 from 表名 order by 字段1 排序方式1, 字段2 排序方式2``
     - asc：升序排序
     - desc：降序排序
   - 分页查询
     - limit： ``select 字段列表 from 表名 limit 起始索引,查询记录数;``
   - 执行顺序
     <img width="1135" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/929bcfae-01d1-47ce-a675-6454eef85031">

 - DCL：数据**控制**语言（**创建数据库用户、控制数据库的访问权限**）


# 函数

## 字符串函数
 - 字符串拼接：concat(c1,c2,c3,...,cn)
 - 全转为小写：LOWER(c)
 - 全转为大写：UPPER(c)
 - 左填充： lpad()
 - 右填充： rpad()
 - 去除空格：trim() 去除头部和尾部的空格
 - 截取字符串：substring()
   ```
   update emp set workno = lpad(workno, 5, '0');
   ```

## 数值函数
- 向上取整：CEIL(x)
- 向下取整：FLOOR()
- 返回x/y的模：MOD(x,y)
- 返回0-1的随机数：RAND()
- 求参数x的四舍五入的值，保留y位小数：ROUND(x,y)

## 日期函数

- curdate() : 返回当前日期
- curtime() : 返回当前时间
- now() :     返回当前日期和时间
- year(date) : 获取指定date的年份
- month(date): 获取指定date的月份
- day(date)  : 获取指定date的日期
- date_add(date,interval expr type) : 返回一个日期/时间值加上一个时间间隔expr后的时间值
- datediff(date1, date2): 返回起始时间date1 和结束时间date2之间的天数

  
# 索引

 - 定义：一种（帮助存储引擎快速获取数据的）**数据结构**
 - 使用索引可以提高查询速度，但
   - 1.需要占用物理空间，数量越大，占的越多
   - 2.创建索引和维护索引需要耗费时间，这种时间随着数据量的增加而增大
   - 3.会降低表的增删改的效率，每次增删改索引，B+树都需要进行动态维护
## 使用索引的情况
   - 字段有**唯一性限制**的，比如商品编码
   - 经常用于**WHERE查询条件**的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
   - 经常用于**GRUOUP BY和ORDER BY**的字段，这样在查询的时候就不需要再去做一次排序了。因为建立索引之后在 B+Tree 中的记录都是排序好的
## 不适用索引的情况
   - WHERE 条件，GROUP BY，ORDER BY 里用不到的字段，**索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的**。
   - 字段中存在**大量重复数据**，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
   - **表数据较少**
   - **经常更新的字段**，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

## 分类：
   - 按**数据结构**分类：B+tree索引、Hash索引、Full-text索引
     - InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，**B+Tree** 索引类型也是 MySQL 存储引擎采用最多的索引类型。
     - B+Tree 相比于 B 树和二叉树来说，最大的优势在于**查询效率很高**，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 **3-4次**。
     - 二级索引（非主键）需要查**两个B+Tree**才能查到数据
       - eg：select * from product where product_no = '0002';其中product_no不是主键，主键是id，这个就是二级索引
       - 二级索引的B+Tree的叶子放的是对应主键的值，即上述语句会首先找product_no = '0002'对应的id值（一次B+Tree），然后再根据id返回一行数据（又一次B+Tree），这个过程也叫做**回表**。
       - 但是，如果上述要查询的不是整行数据（*），而是id，就查一次。
     <img width="739" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/abd503cc-b7d4-450a-9e06-d33f9ab8131d">
     
   
   - 按**物理存储**分类：聚簇索引（主键索引）、二级索引（辅助索引）
   - 按**字段特性**分类：主键索引、唯一索引、普通索引、前缀索引
     - 主键索引**不能为空**，一张表只能有**一个**主键索引
     - 唯一索引的**值必须唯一**，一张表可以有**多个**主键索引
     - 普通索引就是建立在普通字段上的索引，**不要求是否为空，也不要求值必须唯一**
     - 前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上，使用前缀索引的目的是为了**减少索引占用的存储空间，提升查询效率**。
   - 按**字段个数**分类：单列索引、联合索引
     - 单列索引：建立在**单列**上的索引
     - 联合索引：建立在**多列**上的索引
       - 必须遵循最左匹配原则
     - 索引下推：
## B+Tree和B Tree
   - B+Tree只在叶子结点存储数据，B-Tree非叶子节点也存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点
   - B+Tree 叶子节点采用的是**双链表连接**，适合 MySQL 中常见的**基于范围的顺序查找**，而 B-Tree无法做到这一点
## B+Tree和二叉树
   - B+Tree在处理**大规模数据和磁盘存储**时具有明显的优势（树较矮），**O(logdN)**
   - 二叉树适合处理**较小数据量（内存）** ，**O(logN)**
## B+Tree vs Hash
   - Hash 在做**等值查询**的时候效率贼快，搜索复杂度为 **O(1)**，但是**不适合做范围查询**
   - 
## 优化索引的方法

 - 前缀索引优化
   - 使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小
   - 不能使用前缀索引的情况
     - 1.order by 就无法使用前缀索引；
     - 2.无法把前缀索引用作覆盖索引；
 - 覆盖索引优化
   - 可以直接从二级索引中查询得到记录，避免回表的操作
   
 - 主键索引最好自增
   - InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。
 - 索引最好设置为NOT NULL
   - 索引列存在NULL值会导致优化器在做索引选择的时候更加复杂，更加难以优化
   - NULL是一个没有意义的值，但是它会**占用物理空间**，所以会带来存储空间的问题 
 - 防止索引失效


## 数据页
 - InnoDB是以**数据页**为单位进行读写数据的
 - 数据页的组成：**文件头、页头、最小最大记录、用户记录、空闲空间、页目录、文件尾**
<img width="738" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/7bb07966-0f61-4ee1-a9e4-7c53c32c724d">

 - 文件头：含有两个指针，分别指向前一个和后一个数据页
 - 用户记录：按照主键顺序组成单向链表（**删除、插入方便，检索要顺序查询，效率不高**）
 - 页目录：用户记录的索引，为了能够快速找到记录

## 索引失效

 - 使用**左或者左右模糊匹配**的时候（``like %xx``或者 ``like %xx%``），会造成索引失效
   - 原因：B+树是按照**索引值有序排列存储**的，只能根据**前缀**进行比较。
 - 对索引**使用函数**，会造成索引失效
   - 原因：索引保存的是索引字段的原始值，而不是经过函数计算后的值。（函数计算之后的值与索引的值不一样了）
   - **MySQL 8.0之后，索引特性增加了函数索引**，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据
 - 对索引进行**表达式计算**
   - eg：`` select * from t_user where id + 1 = 10; ``
   - 原因：使用索引必须是索引的原始值，表达式计算之后的值不是原始值。
   - 但 `` select * from t_user where id = 10 - 1; ``，这个语句是走索引的，不属于表达式计算
 - 对索引进行**隐式类型转换**
   - 一个字段如果是字符类型，而查询的条件输入是整型，这时就会发生隐式类型转换，将整型转换为字符类型，导致索引失效
   - 相反，如果一个字段是整型，当输入是字符类型时，这时会走索引  
                             
   - MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。
 - 联合索引最左匹配，不遵循会失效
   - 原因：在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。
   - 多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引
   - 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配。
   - eg：创建了一个联合索引``（a,b,c）``，走联合索引的例子：
     - `` where a=1;``
     - `` where a=1 and b=2 and c=3;``
     - `` where a=1 and b=2;``
   - 不走索引的例子：
     - `` where b=2;``
     - `` where c=3;``
     - `` where b=2 and c=3;``
   - 即必须要有个``a``才能去索引中匹配，最左指的就是索引``(a,b,c)``中最左边的一个字段``a``，
   - `` where a=1 and c=3;``，是否走索引？
     - MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。（``a``走索引，然后回表）
     - 从 MySQL 5.6 之后，有一个**索引下推**功能，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。（索引下推，``a``走完索引，会判断索引中是否包含c）
   - **索引下推**
     - 截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 ``(a, b, c)`` 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。
   - Where 子句中的OR
     - 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。
     - eg：`` select * from t_user where id = 1 or age = 18;``
     - 只要上述条件列不是索引列，就会进行全表扫描
     - 将age设置为索引列，就可以走索引
    





# 事务

 -  InnoDB 引擎支持事务，MyISAM 引擎就不支持事务

## 事务的特性（ACID）
 - 原子性（Atomicity）：一个事务，**要么全部完成，要么全部失败，不会结束在中间某个环节**，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从没被执行过。
 - 一致性（Consistency）：**事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态**
 - 隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，**隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致**，
 - 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
 - 如何**保证**事务的四个特性？
   - 1.**Redo Log（重做日志**）   ->   **持久性**
   - 2.**Undo Log（回滚日志）**   ->   **原子性**
   - 3.**MVCC（多版本并发控制）**   ->   **隔离性**
   - 4.**持久性+原子性+隔离性**   ->   **一致性**
   
## 并行事务会引发的问题
 - **脏读**
   - 如果一个事务**读到**了另一个**未提交事务修改过的数据**
 - **不可重复读（前后两次读到的数据不一样）**
   - 在一个事务内多次读取同一个数据，前后两次读到的数据不一样
 - **幻读（前后两次的记录数量不一样）**
   - 在一个事务内多次查询某个符合查询条件的记录数量，前后两次查询到的记录数量不一样
 - **严重性**排序：**脏读  >  不可重复读  >  幻读**

 - 隔离级别（**串行化  >  可重复读  >  读提交  >  读未提交**）
   - 1.**读未提交（read uncommitted）**：当一个事务还没提交时，它做的变更就能被其他事务看到
   - 2.**读提交（read committed）**：一个事务提交之后，它做的变更才能够被其它事务看到
   - 3.**可重复读（repeatable read）**：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB引擎的默认隔离级别**
   - 4.**串行化（serializable）**：会被记录加上读写锁，在多个事务对这条记录进行读写操作时，**如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成**，才能继续执行
 - 隔离级别具体实现：
   - 对于**读未提交**的事务：因为可以读到未提交事务修改的数据，所以直接读取最新的数据
   - 对于**串行化**的事务：通过加读写锁的方式来避免并行访问
   - 对于**读提交**和**可重复读**的事务：通过Read View来实现（数据快照）
     - 两个事务的区别在于创建Read View的时机不同，
     - 读提交时在**每个语句执行前**都会重新生成一个Read View
     - 可重复读是**在启动事务时**生成一个Read View，整个事务期间都在使用这个Read View


## Read View

 - 四个字段
   
   <img width="753" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/36f2334b-a00c-4fff-b1b3-32aca99cf47e">
   
   - **m_ids**：创建Read View时，当前数据库中**活跃事务**（**启动了但还未提交的事务**）的事务id列表，
  
   - **min_trx_id**：活跃事务中id最小的事务
   - **max_trx_id**：创建Read View时当前数据库应该给下一个事务的id值，也就是全局事务中最大的事务id值+1
   - **creator_trx_id**：创建Read View的事务的事务id

 - 隐藏字段
   - InnoDB存储引擎的数据库表，聚簇索引记录中都会包含两个隐藏列
     - trx_id：对某条聚簇索引进行改动的事务id
     - roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到undo日志中，然后这个隐藏列是个指针，指向每一个旧版记录，通过它就可以找到修改前的记录
 - 如果**trx_id < min_trx_id**，说明这个版本是在Read View**创建之前**就由已经提交的事务生成，因此，该版本对于当前事务是**可见**的
 - 如果**trx_id >= max_trx_id**，说明这个版本是在Read View **创建后**才启动的事务生成的，因此，该版本对于当前事务是**不可见**的
 - 如果trx_id在min和max之间，需要进行判断
   - if **trx_id is in m_ids**，表示生成该版本记录的活跃**事务依然活跃（未提交）**，因此，**不可见**
   - if **trx_id is not**，表示**该事务已经提交**，因此，**可见**。

 - **这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。**


## 可重复读是如何工作的



## 读提交是如何工作的




## 避免幻读的解决方案
 MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上**避免**幻读现象（**并不是完全解决了**）
 
 - 快照读（select语句）：开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，**即使中途有其他事务插入了新纪录，是查询不出来这条数据的**，所以就很好了避免幻读问题。
 - 当前读（delete、update、insert语句）：每次执行的时候都是读取最新的数据。




# 锁

## 全局锁
   - 使用全局锁
   ```
   flush tables with read lock
   ```
   - 执行后，**整个数据库**就处于只读状态了，这时其他线程执行以下操作，都会被阻塞
   - 释放全局锁
   ```
   unlock tables
   ```

   - 全局锁应用场景（隔离性）
     - 全局锁主要应用于做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。
   - 缺点：**如果数据库中有很多数据，备份就会花很多的时间**，关键是备份期间，**业务只能读数据，而不能更新数据，这样会造成业务停滞**。
   - 如何避免上述缺点？
     - 如果存储引擎支持的事务是**可重复读**的隔离级别，**在启动备份之前开启事务**，会先创建一个Read View，然后整个事务执行期间都在用这个Read View，**由于MVCC的支持**，备份期间业务**依然可以对数据进行更新操作**。
     - **InnoDB（事务隔离级别正是可重复读）采用这种方式来备份数据库**，而**MyISAM这种不支持事务的引擎，只能使用全局锁来备份数据库**。
## 表级锁
   - 表锁
     - 加锁
     ```
     lock tables 表名 read/write;
     ```
     - 释放锁
     ```
     unlock tables;
     ```
     - 尽量避免在使用InnoDB引擎的表时用表锁，因为表锁的颗粒度太大，会影响并发性能，因此，InnoDB实现了**颗粒度更细的行级锁**。
   - 元数据锁（Meta Data Lock）
     - 元数据锁是为了保证当用户对表执行CRUD操作时，**防止其他线程对这个表结构做变更**
     - 加锁：对表**执行CRUD操作**时
     - 释放锁：在**事务提交后**才会释放
     
   - 意向锁
     - 当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。
     - **意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突**，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write)发生冲突
     - 表锁和行锁满足：**读读共享，读写互斥，写写互斥**

     - 意向锁的目的是为了**快速判断表里是否有记录被加锁**
   - AUTO-INC锁（在字段自增时使用）
     - AUTO-INC锁是特殊的表锁机制，**锁不再是在事务提交时才释放，而是在执行完插入语句后就立即释放**（在执行**插入语句**时才会使用？）
     - 在MySQL 5.1.122版本开始，InnoDB存储引擎提供了一种**轻量级的锁**来实现自增
       - 该锁给字段赋值一个自增的值后，就释放，而不是在执行完语句后
   - 插入意向锁（意思就是当前记录是否能够插入，给一个标记）
   - 
      
## 行级锁

 - InnoDB支持行级锁，MyISAM不支持
 - Record Lock：记录锁，仅仅把一条记录锁上
 - Gap Lock：间隙锁，锁定一个范围，但是不包含记录本身
 - Next-Key Lock：临键锁，Record Lock + Gap Lock的组合，锁定一个范围，并且锁定记录本身

 - 加锁的对象是**索引**，加锁的基本单位是**next-key lock**
 - 唯一索引**等值查询**
   - 使用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也不同
     - 当查询的记录是**存在**的，在索引树上定位到这一条记录后，将该记录的索引中的next-key lock会退化为**记录锁**（记录锁就是锁一条记录，查询的也是一条记录）
     - 当查询的记录是**不存在**的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的next-key 退化为**间隙锁**（记录不存在，就锁一个范围，这个范围是离这条记录最近的左右两条记录，是开区间）
 - 唯一索引**范围查询**
   - 当唯一索引进行范围查询的时候，会对每一个扫描到的索引加next-key锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁
     - 针对与**大于等于**的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是**存在于表中**，那么该记录的索引中的next-key lock退化成**记录锁**
     - 针对于**小于或者小于等于**的范围查询，要看条件值的记录是否存在于表中
       - if **不在表中**，then 不管是小于还是小于等于条件的范围查询，扫描到种植范围查询的记录时，该记录的索引的next-key锁会退化为**间隙锁**，其他扫描到的记录，都是在这些记录的索引上加next-key锁
       - if 在表中，then 如果是小于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的next-key锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加next-key锁；如果是小于等于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引next-key锁不会退化成间隙锁。其他扫描的记录，都是在这些记录的索引上加next-key锁。
 - 非唯一索引等值查询
   - 在用非唯一索引进行等值查询的时候，因此存在两个索引，一个主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，**但是对主键索引加锁的时候，只有满足查询条件的记录才会对他们的主键索引加锁**。
   - if 记录存在，由于索引值不唯一，所以会存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描的二级索引记录加的是next-key锁，而对于第一个不符合条件的二级索引记录，该二级索引的next-key锁会退化成间隙锁。同时在符合查询条件的记录的主键索引上加记录锁。（）
   - if **记录不存在**，扫描到第一条不符合条件的二级索引记录，**该二级索引的next-key锁会退化成间隙锁**。因为不存在满足查询条件的记录，所以不会对主键索引加锁。（只对二级索引加间隙锁，不对主键加锁）
 - 非唯一索引范围查询
   - **非唯一索引进行范围查询时，对二级索引记录加的都是next-key lock**
 - 没有加索引的查询（全表扫描）
   - 不走索引，是**全表扫描**时，**每一条记录的索引上都会加next-key锁**，这样就相当于锁住的全表，这时如果其他事务对该表进行**增删改**的时候，都**会被阻塞**
   

