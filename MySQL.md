# 索引

 - 定义：一种（帮助存储引擎快速获取数据的）**数据结构**
 - 使用索引可以提高查询速度，但
   - 1.需要占用物理空间，数量越大，占的越多
   - 2.创建索引和维护索引需要耗费时间，这种时间随着数据量的增加而增大
   - 3.会降低表的增删改的效率，每次增删改索引，B+树都需要进行动态维护
## 使用索引的情况
   - 字段有**唯一性限制**的，比如商品编码
   - 经常用于**WHERE查询条件**的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
   - 经常用于**GRUOUP BY和ORDER BY**的字段，这样在查询的时候就不需要再去做一次排序了。因为建立索引之后在 B+Tree 中的记录都是排序好的
## 不适用索引的情况
   - WHERE 条件，GROUP BY，ORDER BY 里用不到的字段，**索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的**。
   - 字段中存在**大量重复数据**，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
   - **表数据较少**
   - **经常更新的字段**，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

## 分类：
   - 按**数据结构**分类：B+tree索引、Hash索引、Full-text索引
     - InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，**B+Tree** 索引类型也是 MySQL 存储引擎采用最多的索引类型。
     - B+Tree 相比于 B 树和二叉树来说，最大的优势在于**查询效率很高**，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 **3-4次**。
     - 二级索引（非主键）需要查**两个B+Tree**才能查到数据
       - eg：select * from product where product_no = '0002';其中product_no不是主键，主键是id，这个就是二级索引
       - 二级索引的B+Tree的叶子放的是对应主键的值，即上述语句会首先找product_no = '0002'对应的id值（一次B+Tree），然后再根据id返回一行数据（又一次B+Tree），这个过程也叫做**回表**。
       - 但是，如果上述要查询的不是整行数据（*），而是id，就查一次。
     <img width="739" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/abd503cc-b7d4-450a-9e06-d33f9ab8131d">
     
   
   - 按**物理存储**分类：聚簇索引（主键索引）、二级索引（辅助索引）
   - 按**字段特性**分类：主键索引、唯一索引、普通索引、前缀索引
     - 主键索引**不能为空**，一张表只能有**一个**主键索引
     - 唯一索引的**值必须唯一**，一张表可以有**多个**主键索引
     - 普通索引就是建立在普通字段上的索引，**不要求是否为空，也不要求值必须唯一**
     - 前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上，使用前缀索引的目的是为了**减少索引占用的存储空间，提升查询效率**。
   - 按**字段个数**分类：单列索引、联合索引
     - 单列索引：建立在**单列**上的索引
     - 联合索引：建立在**多列**上的索引
       - 必须遵循最左匹配原则
     - 索引下推：
## B+Tree和B Tree
   - B+Tree只在叶子结点存储数据，B-Tree非叶子节点也存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点
   - B+Tree 叶子节点采用的是**双链表连接**，适合 MySQL 中常见的**基于范围的顺序查找**，而 B-Tree无法做到这一点
## B+Tree和二叉树
   - B+Tree在处理**大规模数据和磁盘存储**时具有明显的优势（树较矮），**O(logdN)**
   - 二叉树适合处理**较小数据量（内存）** ，**O(logN)**
## B+Tree vs Hash
   - Hash 在做**等值查询**的时候效率贼快，搜索复杂度为 **O(1)**，但是**不适合做范围查询**
   - 
## 优化索引的方法

 - 前缀索引优化
   - 使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小
   - 不能使用前缀索引的情况
     - 1.order by 就无法使用前缀索引；
     - 2.无法把前缀索引用作覆盖索引；
 - 覆盖索引优化
   - 可以直接从二级索引中查询得到记录，避免回表的操作
   
 - 主键索引最好自增
   - InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。
 - 索引最好设置为NOT NULL
   - 索引列存在NULL值会导致优化器在做索引选择的时候更加复杂，更加难以优化
   - NULL是一个没有意义的值，但是它会**占用物理空间**，所以会带来存储空间的问题 
 - 防止索引失效


## 数据页
 - InnoDB是以**数据页**为单位进行读写数据的
 - 数据页的组成：**文件头、页头、最小最大记录、用户记录、空闲空间、页目录、文件尾**
<img width="738" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/7bb07966-0f61-4ee1-a9e4-7c53c32c724d">

 - 文件头：含有两个指针，分别指向前一个和后一个数据页
 - 用户记录：按照主键顺序组成单向链表（**删除、插入方便，检索要顺序查询，效率不高**）
 - 页目录：用户记录的索引，为了能够快速找到记录

## 索引失效

 - 使用**左或者左右模糊匹配**的时候（``like %xx``或者 ``like %xx%``），会造成索引失效
   - 原因：B+树是按照**索引值有序排列存储**的，只能根据**前缀**进行比较。
 - 对索引**使用函数**，会造成索引失效
   - 原因：索引保存的是索引字段的原始值，而不是经过函数计算后的值。（函数计算之后的值与索引的值不一样了）
   - **MySQL 8.0之后，索引特性增加了函数索引**，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据
 - 对索引进行**表达式计算**
   - eg：`` select * from t_user where id + 1 = 10; ``
   - 原因：使用索引必须是索引的原始值，表达式计算之后的值不是原始值。
   - 但 `` select * from t_user where id = 10 - 1; ``，这个语句是走索引的，不属于表达式计算
 - 对索引进行**隐式类型转换**
   - 一个字段如果是字符类型，而查询的条件输入是整型，这时就会发生隐式类型转换，将整型转换为字符类型，导致索引失效
   - 相反，如果一个字段是整型，当输入是字符类型时，这时会走索引  
                             
   - MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。
 - 联合索引最左匹配，不遵循会失效
   - 原因：在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。
   - 多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引
   - 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配。
   - eg：创建了一个联合索引``（a,b,c）``，走联合索引的例子：
     - `` where a=1;``
     - `` where a=1 and b=2 and c=3;``
     - `` where a=1 and b=2;``
   - 不走索引的例子：
     - `` where b=2;``
     - `` where c=3;``
     - `` where b=2 and c=3;``
   - 即必须要有个``a``才能去索引中匹配，最左指的就是索引``(a,b,c)``中最左边的一个字段``a``，
   - `` where a=1 and c=3;``，是否走索引？
     - MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。（``a``走索引，然后回表）
     - 从 MySQL 5.6 之后，有一个**索引下推**功能，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。（索引下推，``a``走完索引，会判断索引中是否包含c）
   - **索引下推**
     - 截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 ``(a, b, c)`` 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。
   - Where 子句中的OR
     - 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。
     - eg：`` select * from t_user where id = 1 or age = 18;``
     - 只要上述条件列不是索引列，就会进行全表扫描
     - 将age设置为索引列，就可以走索引
    





# 事务

 -  InnoDB 引擎支持事务，MyISAM 引擎就不支持事务

## 事务的特性（ACID）
 - 原子性（Atomicity）：一个事务，**要么全部完成，要么全部失败，不会结束在中间某个环节**，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从没被执行过。
 - 一致性（Consistency）：**事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态**
 - 隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，**隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致**，
 - 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
