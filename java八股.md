## java

### java面向对象
 - HashMap
 - **JVM**：运行JAVA字节码的虚拟机
   - 不同的系统，其实现不同，目的是为了对于相同的字节码，不同系统的JVM实现会给出相同的结果
   - 
 - **JDK（Java Development Kit）包含JRE，JVM**：它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的**开发套件**.
 - **JRE（Java Runtime Environment）包含JVM**：Java 运行时**环境**。仅包含 Java 应用程序的运行时**环境**和**必要的类库**。
   <img width="629" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/ee2ed250-bdd5-4d08-b7d2-e9405b0e96a3">
 - **字节码**：JVM能够理解的代码就叫字节码（.class文件）。
   - 它不面向任何特定的处理器，只面向虚拟机。
   - Java 语言通过字节码的方式，在一定程度上**解决了传统解释型语言执行效率低的问题**，同时又保留了**解释型语言可移植**的特点。
   - Java 程序**无须重新编译**便可在多种不同操作系统的计算机上运行
 - Java程序转变为机器代码的过程
   - 1.创建.java文件
   - 2.经过javac编译为.class文件（字节码）
   - 3.JVM加载字节码文件，通过解释器逐行解释执行，此时会判断当前代码是否是热点代码（经常被调用的代码）
   - 4.1 如果是热点代码，则通过JIT（Just in Time Compilation）编译器编译，保存热点代码对应的机器码（仅执行一次，下次直接使用）
   - 4.2 如果不是，则正常通过解释器来解释。
   - 5.转换为机器码。
<img width="754" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/2ab21abb-bcbf-4ca9-a1cd-447ac753bd21">

 - 编译型语言：通过编译器将源代码**一次性**翻译成可被该平台执行的机器码
   - 执行速度快，开发效率低
 - 解释型语言：通过解释器一句一句将代码解释为机器代码后再执行
   - 执行速度慢，开发效率高

 - Java语言“编译与解释并存”的原因：
   - Java语句同时具备编译器与解释器的特征
   - Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。

 - **Java与C++相同点与不同点**
   - 相同点：都是面向对象语言，都支持封装、继承和多态
   - 不同点：
     - Java**不提供指针**来访问内存，程序内存更加安全
     - Java**类是单继承，接口是多继承**，C++都是多继承
     - Java有**自动内存管理垃圾回收机制**，不需要程序员手动释放无用内存
     - **C++同时支持方法重载和操作符重载**，但是**Java只支持方法重载**

 - 注释：**代码说明书**（单行注释//、文档注释/* *** */）
   - 代码的注释不是越详细越好。实际上好的代码**本身就是注释**，我们要尽量规范和美化自己的代码来减少不必要的注释。若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。

 - 标识符和关键字
   -

 - 数据类型
   - 基本类型：byte(1字节) boolean（） short（2） int（4） long（8） char（2） float（4） double（8）
   - 包装类型：Byte      Boolean      Short     Integer   Long     Character  Float     Double
 - 基本类型和包装类型
   - **用途**：基本类型用来定义一些常量和局部变量，包装类型用来在方法参数、对象属性中定义变量
   - **存储方式**：基本类型的局部变量存放在Java虚拟机**栈**中的局部变量表中，基本数据类型的成员变量存放在JVM的**堆**中。包装类型属于对象类型，都存在**堆中**。
   - **占用空间**：基本类型占用的空间非常小
   - **默认值**：包装类型不赋值就是null，基本类型有默认值且不是null
   - **比较方式**：基本类型 “==” 比较的是值，包装类型“==” 比较的是对象的内存地址，**所有整型包装类对象之间值的比较，全部使用“equals()”方法**
 - 包装类型的缓存机制
   - Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能
   - Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，Character 创建了数值在 **[0,127]** 范围的缓存数据，Boolean 直接返回 **True** or **False**
   - 如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在**性能和资源**之间的权衡。
   - 两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。
 - 自动装箱与拆箱
   - 装箱：将基本类型用它们对应的引用类型包装起来；
   - 拆箱：将包装类型转换为基本数据类型；
   ```
   Integer i = 10; ==>Integer i = Integer.valueof(10);   //装箱
   int n = i;     ==> int n = i.intValue();        //拆箱
   ```




 - 面向对象和面向过程的区别
   - 面向过程：把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题
   - 面向对象：先抽象出对象，然后用对象执行方法的方式解决问题。面向对象开发的程序一般更易维护、易复用、易扩展
  
 - 面向对象三大特征
   - **封装**。把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。
   - **继承**。使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。
     - 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
     - 子类可以拥有自己属性和方法，即子类可以对父类进行扩展
     - 子类可以用自己的方式实现父类的方法
   - **多态**。一个对象具有多种的状态，具体表现为父类的引用指向子类的实例
     - 对象类型和引用类型之间具有继承（类）/实现（接口）的关系
     - 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定
     - 多态不能调用“只在子类存在但在父类不存在”的方法
     - 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法

### 接口与抽象类
   - 共同点
     - 都不能被**实例化**
     - 都可以包含**抽象方法**
     - 都可以有**默认实现的方法**
   - 不同点
     - 接口主要用于**对类的行为进行约束**，你实现了某个接口就具有了对应的行为。抽象类主要用于**代码复用**，强调的是**所属关系**
     - 一个类只能**继承一个抽象类**，但可以**实现多个接口**
     - 接口内的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认default，可以在子类中被重新定义，也可以被重新赋值。
### 深拷贝与浅拷贝、引用拷贝
   - 深拷贝：直接复制整个对象，包括对象内部的对象
   - 浅拷贝：在堆上新建一个对象，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址（拷贝对象与原对象共用一个内部对象）
   - 引用拷贝：两个不同的引用同时指向同一个对象
### String、StringBuffer、StringBuilder
   - String：对象不可变、线程安全（常量），对其进行修改时都会创建一个新的对象，并改变对象引用
     - 不可变原因↓
     - 1.保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法（**只能访问，没有提供对其进行修改的方法**）。
     - 2.String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变
   - StringBuffer：可变、线程安全（加了同步锁），对对象本身进行修改
   - StringBulider：可变、非线程安全，对对象本身进行修改
   - 在 **Java 9** 之后，String、StringBuilder 与 StringBuffer 的实现改用 **byte** 数组存储字符串（之前使用**char**，这样更加节省空间）。

 - 字符串常量池：JVM为了提升性能和减少内存消耗针对字符串（String类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建
 - String.intern()：将指定的字符串对象的引用保存在字符串常量池

### 异常
   <img width="767" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/ac9b27b2-1e97-4bdd-b0a2-af1a5b980e67">
 - Exception与Error
   - Exception：程序本身可以处理，可以通过try-catch
   - Error：程序无法处理的异常

### 泛型
“泛型”意味着编写的代码可以被**不同类型**的对象所**重用**。
   - Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性
   - 编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。

 - 泛型的使用方式
   - 泛型类
   ```
   public class Generic<T>{

       private T key;
   
       public Generic(T key){
           this.key = key;
       }

       public T getKey(){
           return key;
       }
   }
   ```
     - 实例化泛型类  
       ``Generic<Integer> genericInteger = new Generic<Integer>(123456);``
   - 泛型接口
   ```
   public interface Generator<T>{
       public T method();
   }
   ```
     - 实现泛型接口，不指定类型：
       ```
       class GeneratorImpl<T> implements Generator<T>{
           @override
           public T method(){
               return null;
           }
       }
       ```
     - 实现泛型接口，指定类型
       ```
       class GeneratorImpl<T> implements Generator<String>{
           @override
           public String method(){
               return "hello";
           }
       }
       ```
   - 泛型方法
     ```
     public static <E> void printArray(E[] inputArray){
         for( E element: inputArray){
             System.out.printf("%s",element);
         }
         System.out.println();
     }
     ```
     - 使用方法
       ```
       Integer[] intArray = {1,2,3};
       String[] stringArray = {"Hello","World"};
       printArray(intArray);
       printArray(stringArray);
       ```
   - 在 java 中泛型只是一个占位符，必须在传递类型后才能使用
### 反射
   - 反射赋予了我们在运行时分析类以及执行类中方法的能力
   - 通过反射，可以获得任意一个类的所有属性和方法，还可以调用这些方法和属性
   - 实现Java反射的类
     - 1.Class：表示正在运行的Java应用程序中的**类和接口**（所有获取对象的信息都需要Class类来实现）
     - 2.Field：提供有关类和接口的**属性**信息，以及对它的动态访问权限
     - 3.Constructor：提供关于类的单个**构造方法**的信息以及它的访问权限
     - 4.Method：提供类或接口中某个**方法的**信息
   - 优点
     - 1.能够在运行时动态获取类的实例，**提高灵活性**；
     - 2.与动态编译结合
   - 缺点
     - 1.使用反射**性能较低**，需要解析字节码，将内存中的对象进行解析
       - 解决方案1：通过**setAccessible(true)关闭JDK的安全检查**来提升反射速度
       - 解决方案2：多次创建一个类的实例时，有**缓存**会快很多
       - 解决方案3：**ReflectASM**工具类，通过**字节码生成的方式**加快反射速度。
     - 2.**相对不安全，破坏了封装性**（通过反射，类中的私有属性和方法都能调用）
### 代理模式
  - 代理模式
    - 使用代理对象来代替对真是对象的访问，这样都可以在不修改原目标对象的前提下，提供额外的功能操作扩展目标对象的功能。
    - 作用：**扩展目标对象的功能**，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。
    - 优点
      - 1.代理模式能够协调调用者和被调用者，在一定程度上**降低了系统的耦合度**。
      - 2.可以灵活地**隐藏被代理对象的部分功能和服务**，也**增加了额外的功能和服务**。
    - 缺点
      - 1.性能没有直接调用高
      - 2.提高了代码的复杂度
  - 静态代理
    - 目标对象的每个方法的增强都是**手动完成**的，
    - 非常不灵活（接口一旦新增加方法，目标对象和代理对象都要进行修改）
    - 麻烦，需要对每个目标类都单独写一个代理类
  - 动态代理
    - 相对于静态代理来说，**动态更加灵活**，我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以**直接代理实现类**
    - 从JVM角度来说，动态代理是**在运行时动态生成类字节码，并加载到JVM中**的
    - Spring AOP、RPC 框架的实现都依赖了动态代理

  - JDK动态代理机制
    - 核心：一个类（Proxy类）、一个接口（InvocationHandler接口）
    - Proxy类
      - Proxy类中使用频率最高的方法是：newProxyinstance()，这个方法主要用来**生成一个代理对象**
      ```
      public static Object newProxyInstance(ClassLoader loader,
                                            Class<?>[] interfaces,
                                            InvocationHandler h)
          throws IllegalArgumentException
      {
        ......
      }

      ```
      - 参数1：loader，类加载器，用于加载代理对象
      - 参数2：interfaces，被代理类实现的一些接口；
      - 参数3：h，实现了InvocationHandler接口的对象
    - InvocationHandler接口
      - 要实现动态代理，还需要实现InvocationHandler接口来自定义处理逻辑。
      ```
      public interface InvocationHandler {
      
          /**
           * 当你使用代理对象调用方法的时候实际会调用到这个方法
           */
          public Object invoke(Object proxy, Method method, Object[] args)
              throws Throwable;
      }

      ```
      - 参数1：proxy，动态生成的代理类
      - 参数2：method，与代理类对象调用的方法相对应
      - 参数3：args，当前method方法的参数
    - 缺点：**只能代理实现了接口的类**
 - CGLIB动态代理机制
   - 在运行时可以对**字节码进行修改和动态生成**
   - 通过**继承**方式实现代理
   - 一个接口（MethodInterceptor接口）和一个类（Enhancer类）
     - MethodInterceptor接口
       - 需要自定义MethodInterceptor 并重写intercept方法，intercept用于拦截增强被代理类的方法
       ```
       public interface MethodInterceptor
       extends Callback{
           // 拦截被代理类中的方法
           public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy) throws Throwable;
       }
       ```
       - 参数1：obj，被代理的对象（需要增强的对象）
       - 参数2：method，被拦截的方法（需要增强的方法）
       - 参数3：args，方法入参
       - 参数4：proxy，用于调用原始方法
 - JDK动态代理与CGLIB动态代理对比
   - JDK动态代理只能代理**实现了接口的类**或者**直接代理接口**，而CGLIB可以代理**未实现任何接口的类**。另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
   - 就二者的**效率**来说，**JDK动态代理更优秀**，随着JDK版本的升级，这个优势更加明显
 - 静态代理和动态代理的对比
   - **灵活性**：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改
   - **JVM层面**：静态代理**在编译时**就将接口、实现类、代理类这些都变成了一个个实际的class文件，而动态代理是**在运行时**动态生成类字节码，并加载到JVM中的。
### JAVA集合
  Java集合，也叫做容器，主要是由两大接口派生而来
  - Collection接口：主要用于存放单一元素
    - 子接口1：List，存储的元素都是有序的
      - ArrayList与Array(数组)的区别
        - 1.ArrayList可以动态扩容，Array在创建之后长度不能被改变
        - 2.ArrayList可以使用泛型来保证类型安全，Array不可以
        - 3.ArrayList只能存储对象（在存储基本类型时，需要使用其对应的包装类Integer、Double等），Array既可以存储基本类型数据，也可以存储对象
        - 4.ArrayList支持插入、删除、遍历等常见操作，并且提供了丰富的API操作方法，比如add()，remove（）等。Array只是一个固定长度的数组，只能按照其下标来访问元素，不具备动态添加、删除元素的能力。
        - 5.ArrayList创建时不需要指定大小，Array需要指定大小。
    - 子接口2：Set，存储的元素不重复
    - 子接口3：Queue，按特定的排队规则来确定先后顺序，存储的元素是有序的，可重复的
  - Map接口：主要存放键值对，key是无序的、不可重复的，每个键最多映射到一个值
    - HashMap：
      - JDK1.8之前由数组+链表组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）
      - 1.8之后再解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间
    - LinkedHashMap：
      - 继承自HashMap,由数组+链表或数组+红黑树组成
      - 在HashMap的基础上增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序
      - 通过对链表进行相应的操作，实现了**访问顺序**相关逻辑
    - HashTable：数组+链表，数组是主体，链表则是为了解决哈希冲突而存在（与HashMap有啥区别？）。
      - 与HashMap区别
        - 1.两者父类不同：HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable(可复制)、Serializable(可序列化)这三个接口。
        - 2.对外提供的接口不同：Hashtable比HashMap多提供了elments() 和contains() 两个方法。 elments() 方法继承自 Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实 上，contansValue() 就只是调用了一下contains() 方法。
        - 3.对null的支持不同：HashTable：key和value都不能为null，HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性;可以有多个 key值对应的value为null
        - 4.安全性不同：HashMap是非线程安全的，HashTable是线程安全的。
        - 5.初始容量大小和每次扩充容量大小不同
        - 6.计算hash值的方法不同
 - HashMap与HashSet区别
   - HashMap存放**键值对**，HashSet存放**对象**
 - HashMap与TreeMap区别
   - TreeMap实现了**NavigableMap接口（针对集合内的搜索能力）**和**SortedMap接口（集合内元素根据键排序）**
   - 相对于HashMap，TreeMap主要多了对集合中的元素**根据键排序的能力**以及对集合内元素的**搜索能力**

 - HashSet如何检查重复？
   - 首先判断hashcode值是否相同→→→→→→→**不同**→→→→→→→→ 表示不重复
   - ↓↓↓↓↓↓**相同**↓↓↓↓↓↓
   - 使用equals方法来检查两个对象是否真的相同。
 - TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。

 - ConcurrentHashMap 和 HashTable 的区别
   - 底层数据结构：
     - **JDK1.7**的ConcurrentHashMap主要采用**分段数组+链表**实现，**JDK1.8**采用的是**数组+链表/红黑树**。
     - HashTable和之前的HashMap的底层数据结构类似都是采用**数组+链表**，数组是主体，链表则是主要为了解决哈希冲突而存在的。
   - 实现线程安全的方式：
     - **JDK1.7** ConcurrentHashMap对整个桶数组进行了**分割分段**（segment，分段锁）,每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。
     - **JDK1.8** ConcurrentHashMap直接用**Node数组+链表/红黑树**的数据结构来实现，**并发控制使用``synchronized``和CAS操作**。
     - HashTable(同一把锁)：**使用``synchronized``来保证线程安全，效率非常低下**。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，竞争会越来越激烈，效率越来越低。
 - ConcurrentHashMap的key和value为什么不能为null？
   - 为了避免**二义性**，不清楚是否是不存在还是值为null
 - HashMap可以存储null的key和value，但null作为键只能有一个，null作为值可以有多个。
 - **在多线程下无法正确判定键值是否存在，单线程是可以的**。


### 并发
 
 #### 进程与线程
 - **进程**是程序的一次执行过程，是系统运行程序的基本单位。
 - **线程**是与进程更小的一个执行单位。一个进程在执行的过程中可以产生多个线程。同类的多个线程共享进程的栈和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈
 - **一个 Java 程序的运行是 main 线程和多个其他线程同时运行。**
 - JAVA线程和操作系统的线程
   - **现在的 Java 线程的本质其实就是操作系统的线程。**
![image](https://github.com/hhhhby/Redis/assets/113978854/001ebf6c-ef9e-4fb9-b692-f760a9f0c43e)

 - 一个进程中可以有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。
 - 线程是进程划分成的更小的运行单位。
 - 线程和进程最大的不同在于基本上个进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。
 - 线程执行开销小，但不利于资源的管理和保护；但进程正相反。
 - 一个进程在其执行的过程中可以产生多个线程。与进程不同的是**同类的多个线程共享进程的堆和方法区资源**，但**每个线程都有自己从程序计数器、虚拟机栈和本地方法栈**
#### JAVA线程与操作系统的线程区别
 - JDK 1.2之前，Java是**基于绿色线程（Green Threads）实现**的，这是一种**用户级线程**，不依赖于操作系统
 - 1.2及以后，Java线程改为**基于原生线程（Native Threads）实现**，也就是说JVM直接使用操作系统原生的**内核级线程（内核线程）** 来实现Java线程
 - 现在的 Java 线程的本质其实就是操作系统的线程。
 - 线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有三种：
   - 1.一对一 （一用户 -> 一内核）
   - 2.多对一 （多用户 -> 一内核）
   - 3.多对多 （多用户 -> 多内核）
   - 在Windows和Linux等主流操作系统中，Java线程采用的是一对一的线程模型，也就是**一个Java线程对应一个系统内核线程**。
 - 线程和进程最大的不同在于基本上各**进程是独立**的，而各线程则不一定，因为**同一进程中的线程**极有可能**会相互影响**。**线程执行开销小，但不利于资源的管理和保护，而进程正相反**。
 - 为什么程序计数器、虚拟机栈和本地方法栈是私有的？为什么堆和方法区是线程共享的？
   - 程序计数器的作用：
     - 1.**字节码解释器通过改变程序计数器来依次读取指令**，从而实现**代码的流程控制**，如：顺序执行、选择、循环、异常处理。
     - 2.在**多线程的情况下**，程序计数器用于**记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道线程上次运行到哪了。
   - 虚拟机栈和本地方法栈为什么是私有的？
     - 虚拟机栈（Java方法）：每个Java方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程
     - 本地方法栈（Native方法）：与虚拟机栈所发挥的作用相似（应该是在Native方法执行前会创建一个栈帧）
     - 为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。
 - 堆和方法区
   - 堆：进程中最大的一块内存，主要用于存放新创建的对象（几乎所有对象都在这里分配内存）
   - 方法区：主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

 #### 创建线程
   - 继承Thread类，实现Runnable接口，实现Callable接口，使用线程池，使用CompletableFuture类，属于是在Java代码中使用**多线程的方法**
   - 真正创建Java线程只有一种方式：通过 `` new Thread().start()``创建。
 #### 线程的生命周期和状态
  - Java线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态中的一个
    - NEW: 初始状态，线程被创建出来但没有被调用start()
    - RUNNABLE: 运行状态，线程调用了start()等待运行的状态
    - BLOCKED: 阻塞状态，需要等待锁释放
    - WAITING: 等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）
    - TIME_WAITING: 超时等待状态，可以在指定的时间后自行返回而不是像WAITING那样一直等待
    - TERMINATED: 终止状态，表示该线程已经运行完毕

  - 线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。

#### 线程上下文切换
 - 线程在执行过程中会有自己的**运行条件和状态**（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用CPU状态中退出。
   - 主动让出CPU，比如调用了sleep(),wait()等
   - 时间片用完，因为操作系统要防止一个线程或进程长时间占用CPU导致其他线程或者进程饿死
   - 调用了阻塞类型的系统中断，比如请求IO，线程被阻塞
   - 被终止或结束运行
   - 这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用CPU的时候恢复现场，并记载下一个将要占用CPU的线程上下文。这就是所谓的上下文切换。

#### Thread#sleep()方法和Object#wait()方法
 - 共同点：两者都可以暂停线程的执行
 - 不同点：
   - sleep()方法没有释放锁，而wait()释放了锁
   - wait()通常被用于线程间交互/通信，sleep()通常被用于暂停执行（sleep没有释放锁，肯定别的线程也用不了，不就是暂停执行；wait释放了锁，就是让别的线程来拿锁，就交互了）
   - wait()方法被调用后，线程不用自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒，或者也可以使用wait(long timeout)超时后线程会自动苏醒
   - sleep()是Thread类的静态本地方法，wait()是Object类的本地方法。
 - 为什么wait方法不定义在Thread中？
   - wait()是让获得对象锁的线程实现等待，会释放当前线程占有的对象锁。每个对象（Object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WARITING状态，自然要操作对应的对象（Object）而非当前的线程（Thread）
 - 为什么sleep方法定义在Thread中？
   - 因为sleep是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。
  
 - 可以直接调用Thread类的run方法吗？
   - new一个Thread，线程进入了新建状态。调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。
   - 但是，直接执行run()方法，会把run方法当成一个main线程下的普通方法区执行，并不会在某个线程中执行它，所以这并不是多线程工作。
   - 调用**start方法可以启动线程并使线程进入就绪状态**，直接执行run方法的话**不会以多线程的方式**执行。
#### 多线程
 - 并发与并行
   - 并发：同一时间段两个或两个以上的作业执行（每个作业会分到一点时间，在一个时刻是只有一个作业执行的）
   - 并行：同一时刻两个或两个以上的作业执行
 - 同步与异步
   - 同步：发出一个调用后，在没有得到结果之前，该调用就不可以返回，一直等待
   - 异步：调用在发出之后，不用等待返回结果，该调用直接返回。
 - 为什么要使用多线程？
   - 从**计算机底层**来说：线程可以比作是轻量级的进程，是程序执行的最小单位，线程的切换和调度的成本远远小于进程。另外，多核CPU时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
     - 单核时代：在单核时代多线程主要是为了提高单进程利用CPU和IO系统的效率。
     - 多核时代：多核时代多线程主要是为了提高进程利用多核CPU的能力。
   - 从**当代互联网发展趋势**来说：现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以打打提高系统整体的并发能力以及性能。
 - 使用多线程带来的问题
   - 并发编程的目的就是为了能提高程序的执行效率进而提高程序的运行速度，
   - 但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如内存泄漏、死锁、线程不安全等等。
 - 如何理解线程安全与不安全?
   - 线程是否安全是在多线程环境下对于**同一份数据的访问**是否能够保证其**正确性**和**一致性**的描述
     - 线程安全是指在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性
     - 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问可能会导致数据混乱、错误或者丢失
 - 单核CPU运行多个线程效率一定会高吗
   - 单核CPU同时运行多个线程的效率是否会高，取决于**线程的类型**和**任务的性质**。一般来说，有两种类型的线程：CPU密集型和IO密集型
     - CPU密集型：主要进行计算和逻辑处理，需要占用大量的CPU资源
     - IO密集型：主要进行输入输出操作，如读写文件、网络通信等，需要等待IO设备的相应，而不占用太多的CPU资源
   - 在单核CPU中，同一时刻只能有一个线程在运行，其他线程需要等待CPU的时间分配。
     - 如果线程是CPU密集型的，那么多个线程同时运行会导致频繁的线程切换，增加系统的开销，降低了效率。
     - 如果线程是IO密集型的，那么多个线程同时运行可以利用CPU在等待IO时的空闲时间，提高了效率。
   - 因此，对于单核CPU来说，如果任务是CPU密集型的，那么开很多线程会影响效率；如果任务是IO密集型的，那么开很多（不能超过系统能够承受的上限）线程会提高效率。
#### 死锁

 - 线程死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源释放。由于线程被无限期地阻塞，因此程序不可能正常终止。
 - 产生死锁的四个必要条件
   - **互斥条件**：该资源**任意一个时刻只由一个线程**占用
   - **请求与保持条件**：一个线程因请求资源而阻塞时，**对已获得的资源保持不放**
   - **不剥夺条件**：线程已获得的资源**在未使用完之前不能被其他线程强行剥夺**，**只有自己使用完毕后才释放资源**
   - **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系
 - 如何检测死锁
   - 使用jmap、jstack等命令查看JVM线程栈和堆内存的情况
   - 采用VisualVM、JConsole等工具进行排查
 - 预防和避免死锁
   - 预防死锁，破坏死锁产生的必要条件即可：
     - 破坏请求与保持条件：一次性申请所有的资源
     - 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源
     - 破坏循环等待条件：靠按序申请资源来预防，按某一顺序申请资源，释放资源则反序释放。
    
   - 避免死锁
     - 借助于算法对资源分配进行计算评估，使其进入安全状态。
     - 安全状态指的是系统能够按照某种线程推进顺序来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。

#### JMM(Java 内存模型)

 - JMM主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的**可见性**

 - CPU缓存模型
   - CPU缓存是为了解决**CPU处理速度和内存处理速度**不对等的问题
   - CPU Cache缓存的是内存数据用于解决CPU处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题

 - **编译器优化重排**：编译器 在不改变单线程程序语义的前提下，重新安排语句的执行顺序
 - **指令并行重排**：现代处理器采用了指令级并行技术（Instruction-Level Parallelism, ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
 - Java 源代码会经历 **编译器优化重排 -> 指令并行重排 -> 内存系统重排** 的过程，最终才变成操作系统可执行的指令序列
 - **指令重排序可以保证串行语义一致**，但是**没有义务保证多线程间的语义也一致**，所以在多线程下，指令重排序可能会导致一些问题。
 - 编译器和处理器的指令的处理方式不一样。对于编译器，通过禁止特定类型的编译器重排序的方式来禁止重排序。对于处理器，通过插入内存屏障（Memory Barrier,或有时叫做内存栅栏, Memory Fence）的方式来禁止特定类型的处理器重排序。
 - 指令并行重排和内存系统重排都属于是处理器级别的指令重排序。

 - 内存屏障是一种CPU指令，用来禁止处理器指令发生重排序，从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。

 - JMM
   - Java是最早尝试提供内存模型的编程语言。
   - 一般来说，编程语言也可以直接复用操作系统层面的内存模型。作为**跨平台语言**，Java需要自己提供一套内存模型来屏蔽系统差异。
   - 对于Java来说，可以把JMM看作是Java定义的并发编程相关的一组规范，
   - 除了抽象了线程和主内存之间的关系之外，其还规定了从Java源代码到CPU可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，
   - 主要目的是**为了简化多线程编程，增强程序可移植性的**。
   - 遵守与并发相关的原则和规范的原因
     - 并发编程下，像CPU多级缓存和指令重排这类设计可能会**导致程序运行出现一些问题**。
   - JMM就是定义了一些原则和规范来解决多线程并发下的问题，开发者可以利用这些规范更方便地开发多线程程序。
##### JMM是如何抽象线程和主内存之间的关系
 - JMM抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。
 - **JDK 1.2之前**，Java的内存模型实现总是从**主存（共享内存）读取变量**，是不需要进行特别的注意的。
 - 在当前的Java内存模型下，线程可以把变量保存到**本地内存**中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。（一个线程将主存中的值改了，另一个线程不知道，还是自己的本地内存中读）
 - 主内存
   - 所有**线程创建的实例对象**存放在主内存中，不管该实例是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。
   - 为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。
 - 本地内存
   - **每个线程都有一个私有的本地内存**，本地内存存储了该线程以读/写共享变量的副本。
   - **每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存**。
   - 如果线程间需要通信，必须通过主内存来进行（**通信需要主内存**）。
   - 本地内存是JMM抽象出来的概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。
##### Java内存区域和JMM区别
 - Java内存区域和JVM的运行时区域相关，定义了**JVM在运行时如何分区存储程序数据**，
 - JMM与Java的并发编程有关，**抽象了线程和主内存之间的关系**就比如说线程之间的共享变量必须存储在主内存中，规定了从Java源代码到CPU可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性。
##### happens-before原则
 - **逻辑时钟**：不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种happens-before关系
 - happens-before产生的原因：为了程序员和编译器、处理器之间的平衡。
   - 程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。
   - 编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化
 - happens-before原则的设计思想（**一个原则就是 只要不改变程序的执行结果，咋样都行**）
   - 为了对编译器和处理器的约束尽可能少，只要**不改变程序的执行结果**，编译器和处理器怎么进行重排序优化都行
   - 对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序
 - happens-before常见规则
   - **程序顺序规则**：一个线程内，按照代码顺序，书写在前面的操作happens-before于书写在后面的操作
   - **解锁规则**：解锁happens-before于加锁
   - **volatile变量规则**：对一个volatile变量的写操作happens-before于后面对这个volatile变量的读操作。
   - **传递规则**：如果A happens-before B，且B happens-before C，那么A happens-before C
   - **线程启动规则**：Thread对象的``start()``方法happens-before于此线程的每一个动作
   - 如果**两个操作不满足上述任意一个** happens-before 规则，那么这两个操作就没有顺序的保障，**JVM 可以对这两个操作进行重排序**。
 - happens-before与JMM的关系
   <img width="692" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/c2369d80-fa67-4d82-ad6b-db07dcc9df68">

 - 并发编程的三个重要特性
   - **原子性**（跟数据库的差不多）
     - 一次操作或多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行
     - Java中，可以借助``synchronized``、各种``Lock``以及各种原子类实现原子性
     - ``synchronized``和各种``Lock``可以保证任意时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用CAS（campare and swap）操作（可能也会用到``volatile``或者``final``关键字）来保证原子操作
   - **可见性**
     - 当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。
     - 在Java中，可以借助``synchronized``、``Lock``以及各种``volatile``实现可见性
     - 如果我们将变量声明为``volatile``，这就指示JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取
       
   - **有序性**
     - 由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序
     - 在Java中，``volatile``关键字可以禁止执行进行重排序优化

#### volatile 关键字

 - ``volatile``关键字可以保证变量的可见性，如果将变量声明为``volatile``，这就指示JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。
 - ``volatile``关键字其实并非是Java语言特有的，它最原始的意义就是禁用CPU缓存。
 - ``volatile``关键字能够保证数据的可见性，但不保证数据的原子性。``synchronized``关键字两者都能保证。
 - ``volatile``关键字除了可以保证变量的可见性，还有一个重要的作用就是防止JVM的指令重排序
 - 如果将变量声明为``volatile``，在对这个变量进行读写操作时，会通过插入特定的内存屏障的方式来禁止指令重排序
 - ``volatile``不能保证对变量的操作是原子性的


#### 乐观锁和悲观锁

 - 悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题（比如共享数据被修改），所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。**共享资源每一次只给一个线程使用，用完后再把资源转让给其他线程**
   - 高并发的情况下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的**上下文切换**，**增加系统的性能开销**。
   - 并且，悲观锁还可能会**存在死锁问题**，影响代码的正常运行。
   - 悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题，是可以考虑使用乐观锁，要视实际情况而定。
 - 乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交**修改**的时候去验证对应的资源是否被其它线程修改了（具体方法）
   - 高并发的情况下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往更胜一筹。
   - 但是，如果冲突频繁发生（**写占比非常多的情况**），会频繁失败和重试，这样同样会非常影响性能，导致CPU飙升
   - 乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。乐观锁主要针对的对象是单个共享变量。
 - 实现乐观锁：乐观锁一般会使用版本号机制或CAS算法实现，CAS算法相对多一些
   - 版本号机制
     - 一本是在数据表中加上一个数据版本号``version``字段，表示数据修改的次数。当数据被修改时，``version``值+1。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
   - CAS算法
     - CAS的全称是Compare And Swap（比较与交换），用于实现乐观锁，被广泛应用于各大框架中。CAS的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新
 - 
 - 
## Redis
 - 缓存穿透（一直访问缓存和数据库都不存在的数据）：
   
 - 缓存击穿（热点key突然失效）：
   
 - 缓存雪崩（同一时段大量key同时失效）：
   
 - 跳表
   - 原理
   - 应用
 
