## java

 - HashMap
 - **JVM**：运行JAVA字节码的虚拟机
   - 不同的系统，其实现不同，目的是为了对于相同的字节码，不同系统的JVM实现会给出相同的结果
   - 
 - **JDK（Java Development Kit）包含JRE，JVM**：它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的**开发套件**.
 - **JRE（Java Runtime Environment）包含JVM**：Java 运行时**环境**。仅包含 Java 应用程序的运行时**环境**和**必要的类库**。
   <img width="629" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/ee2ed250-bdd5-4d08-b7d2-e9405b0e96a3">
 - **字节码**：JVM能够理解的代码就叫字节码（.class文件）。
   - 它不面向任何特定的处理器，只面向虚拟机。
   - Java 语言通过字节码的方式，在一定程度上**解决了传统解释型语言执行效率低的问题**，同时又保留了**解释型语言可移植**的特点。
   - Java 程序**无须重新编译**便可在多种不同操作系统的计算机上运行
 - Java程序转变为机器代码的过程
   - 1.创建.java文件
   - 2.经过javac编译为.class文件（字节码）
   - 3.JVM加载字节码文件，通过解释器逐行解释执行，此时会判断当前代码是否是热点代码（经常被调用的代码）
   - 4.1 如果是热点代码，则通过JIT（Just in Time Compilation）编译器编译，保存热点代码对应的机器码（仅执行一次，下次直接使用）
   - 4.2 如果不是，则正常通过解释器来解释。
   - 5.转换为机器码。
<img width="754" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/2ab21abb-bcbf-4ca9-a1cd-447ac753bd21">

 - 编译型语言：通过编译器将源代码**一次性**翻译成可被该平台执行的机器码
   - 执行速度快，开发效率低
 - 解释型语言：通过解释器一句一句将代码解释为机器代码后再执行
   - 执行速度慢，开发效率高

 - Java语言“编译与解释并存”的原因：
   - Java语句同时具备编译器与解释器的特征
   - Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。

 - **Java与C++相同点与不同点**
   - 相同点：都是面向对象语言，都支持封装、继承和多态
   - 不同点：
     - Java**不提供指针**来访问内存，程序内存更加安全
     - Java**类是单继承，接口是多继承**，C++都是多继承
     - Java有**自动内存管理垃圾回收机制**，不需要程序员手动释放无用内存
     - **C++同时支持方法重载和操作符重载**，但是**Java只支持方法重载**

 - 注释：**代码说明书**（单行注释//、文档注释/* *** */）
   - 代码的注释不是越详细越好。实际上好的代码**本身就是注释**，我们要尽量规范和美化自己的代码来减少不必要的注释。若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。

 - 标识符和关键字
   -

 - 数据类型
   - 基本类型：byte(1字节) boolean（） short（2） int（4） long（8） char（2） float（4） double（8）
   - 包装类型：Byte      Boolean      Short     Integer   Long     Character  Float     Double
 - 基本类型和包装类型
   - **用途**：基本类型用来定义一些常量和局部变量，包装类型用来在方法参数、对象属性中定义变量
   - **存储方式**：基本类型的局部变量存放在Java虚拟机**栈**中的局部变量表中，基本数据类型的成员变量存放在JVM的**堆**中。包装类型属于对象类型，都存在**堆中**。
   - **占用空间**：基本类型占用的空间非常小
   - **默认值**：包装类型不赋值就是null，基本类型有默认值且不是null
   - **比较方式**：基本类型 “==” 比较的是值，包装类型“==” 比较的是对象的内存地址，**所有整型包装类对象之间值的比较，全部使用“equals()”方法**
 - 包装类型的缓存机制
   - Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能
   - Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，Character 创建了数值在 **[0,127]** 范围的缓存数据，Boolean 直接返回 **True** or **False**
   - 如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在**性能和资源**之间的权衡。
   - 两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。
 - 自动装箱与拆箱
   - 装箱：将基本类型用它们对应的引用类型包装起来；
   - 拆箱：将包装类型转换为基本数据类型；
   ```
   Integer i = 10; ==>Integer i = Integer.valueof(10);   //装箱
   int n = i;     ==> int n = i.intValue();        //拆箱
   ```




 - 面向对象和面向过程的区别
   - 面向过程：把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题
   - 面向对象：先抽象出对象，然后用对象执行方法的方式解决问题。面向对象开发的程序一般更易维护、易复用、易扩展
  
 - 面向对象三大特征
   - **封装**。把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。
   - **继承**。使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。
     - 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
     - 子类可以拥有自己属性和方法，即子类可以对父类进行扩展
     - 子类可以用自己的方式实现父类的方法
   - **多态**。一个对象具有多种的状态，具体表现为父类的引用指向子类的实例
     - 对象类型和引用类型之间具有继承（类）/实现（接口）的关系
     - 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定
     - 多态不能调用“只在子类存在但在父类不存在”的方法
     - 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法

 - 接口与抽象类
   - 共同点
     - 都不能被**实例化**
     - 都可以包含**抽象方法**
     - 都可以有**默认实现的方法**
   - 不同点
     - 接口主要用于**对类的行为进行约束**，你实现了某个接口就具有了对应的行为。抽象类主要用于**代码复用**，强调的是**所属关系**
     - 一个类只能**继承一个抽象类**，但可以**实现多个接口**
     - 接口内的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认default，可以在子类中被重新定义，也可以被重新赋值。
 - 深拷贝与浅拷贝、引用拷贝
   - 深拷贝：直接复制整个对象，包括对象内部的对象
   - 浅拷贝：在堆上新建一个对象，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址（拷贝对象与原对象共用一个内部对象）
   - 引用拷贝：两个不同的引用同时指向同一个对象
 - String、StringBuffer、StringBuilder
   - String：对象不可变、线程安全（常量），对其进行修改时都会创建一个新的对象，并改变对象引用
     - 不可变原因↓
     - 1.保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法（**只能访问，没有提供对其进行修改的方法**）。
     - 2.String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变
   - StringBuffer：可变、线程安全（加了同步锁），对对象本身进行修改
   - StringBulider：可变、非线程安全，对对象本身进行修改
   - 在 **Java 9** 之后，String、StringBuilder 与 StringBuffer 的实现改用 **byte** 数组存储字符串（之前使用**char**，这样更加节省空间）。

 - 字符串常量池：JVM为了提升性能和减少内存消耗针对字符串（String类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建
 - String.intern()：将指定的字符串对象的引用保存在字符串常量池

 - 异常
   <img width="767" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/ac9b27b2-1e97-4bdd-b0a2-af1a5b980e67">
 - Exception与Error
   - Exception：程序本身可以处理，可以通过try-catch
   - Error：程序无法处理的异常

 - 泛型
   - Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性
   - 编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。

 - 泛型的使用方式
   - 泛型类
   ```
   public class Generic<T>{

       private T key;
   
       public Generic(T key){
           this.key = key;
       }

       public T getKey(){
           return key;
       }
   }
   ```
     - 实例化泛型类  
       ``Generic<Integer> genericInteger = new Generic<Integer>(123456);``
   - 泛型接口
   ```
   public interface Generator<T>{
       public T method();
   }
   ```
     - 实现泛型接口，不指定类型：
       ```
       class GeneratorImpl<T> implements Generator<T>{
           @override
           public T method(){
               return null;
           }
       }
       ```
     - 实现泛型接口，指定类型
       ```
       class GeneratorImpl<T> implements Generator<String>{
           @override
           public String method(){
               return "hello";
           }
       }
       ```
   - 泛型方法
     ```
     public static <E> void printArray(E[] inputArray){
         for( E element: inputArray){
             System.out.printf("%s",element);
         }
         System.out.println();
     }
     ```
     - 使用方法
       ```
       Integer[] intArray = {1,2,3};
       String[] stringArray = {"Hello","World"};
       printArray(intArray);
       printArray(stringArray);
       ```
   - 在 java 中泛型只是一个占位符，必须在传递类型后才能使用
 - 反射
   - 2
## Redis
 - 缓存穿透（一直访问缓存和数据库都不存在的数据）：
   
 - 缓存击穿（热点key突然失效）：
   
 - 缓存雪崩（同一时段大量key同时失效）：
   
 - 跳表
   - 原理
   - 应用
 
