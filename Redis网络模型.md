# 用户空间和内核空间

 - 任何Linux发行版，其系统内核都是Linux。我们的应用都需要通过Linux内核与硬件交互。
<img width="1126" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/e0b49b5c-8506-4e0a-b36a-a4e33796e4da">

 - 为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：
   - 将寻址空间进行隔离，分为**内核空间**和**用户空间**
   - **用户空间**只能执行受限的命令（Ring3)，而且不能直接调用系统资源，必须通过内核提供的接口来访问
   - **内核空间**可以执行特权命令（Ring0)，调用一切系统资源


 - Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：
   - 写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备
   - 读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区
  


# 阻塞IO(Bilockng IO)

 - 读取数据的流程（）
   - 1.用户空间读取数据，指令传到内核空间，开始等待数据
   - 2.内核空间去硬件设备准备数据，数据拷贝至内核空间的缓冲区
   - 3.用户空间的缓冲区拷贝内核空间的缓冲区读取数据
  
 - 阻塞IO，这种模式的性能不高
   <img width="845" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/13458326-90de-47c9-937d-24d9cd60518a">
   - 在等待数据的阶段与从内核拷贝数据到用户控件的阶段，进程都处于阻塞的状态



# 非阻塞IO
 - 非阻塞IO的recvfrom操作会**立即返回结果**而不是阻塞用户进程（没有数据会一直问）
<img width="795" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/eb837c3d-98ec-4bd0-9210-6bd7aac64d4b">
 - 在从内核拷贝数据到用户控件的阶段，进程处于阻塞的状态
 - 在非阻塞IO模型中，用户进程再第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。

# IO多路复用

 - 无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：
   - 如果调用recvfrom时，恰好**没有**数据，阻塞IO会使进程阻塞，非阻塞IO会使CPU空转，都不能充分发挥CPU的作用。
   - 如果调用recvfrom时，恰好**有**数据，则用户进程可以直接进入第二阶段，读取并处理数据
 - 比如服务器端处理客户端Socket请求时，在单线程情况下，只能依次处理每一个socket，如果正在处理的socket恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有其他客户端socket都必须等待，性能自然会很差。



