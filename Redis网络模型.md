# 用户空间和内核空间

 - 任何Linux发行版，其系统内核都是Linux。我们的应用都需要通过Linux内核与硬件交互。
<img width="1126" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/e0b49b5c-8506-4e0a-b36a-a4e33796e4da">

 - 为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：
   - 将寻址空间进行隔离，分为**内核空间**和**用户空间**
   - **用户空间**只能执行受限的命令（Ring3)，而且不能直接调用系统资源，必须通过内核提供的接口来访问
   - **内核空间**可以执行特权命令（Ring0)，调用一切系统资源


 - Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：
   - 写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备
   - 读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区
  


# 阻塞IO(Bilockng IO)

 - 读取数据的流程（）
   - 1.用户空间读取数据，指令传到内核空间，开始等待数据
   - 2.内核空间去硬件设备准备数据，数据拷贝至内核空间的缓冲区
   - 3.用户空间的缓冲区拷贝内核空间的缓冲区读取数据
  
 - 阻塞IO，这种模式的性能不高
   <img width="845" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/13458326-90de-47c9-937d-24d9cd60518a">
   - 在等待数据的阶段与从内核拷贝数据到用户控件的阶段，进程都处于阻塞的状态



# 非阻塞IO
 - 非阻塞IO的recvfrom操作会**立即返回结果**而不是阻塞用户进程（没有数据会一直问）
<img width="795" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/eb837c3d-98ec-4bd0-9210-6bd7aac64d4b">
 - 在从内核拷贝数据到用户控件的阶段，进程处于阻塞的状态
 - 在非阻塞IO模型中，用户进程再第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。

# IO多路复用

 - 无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：
   - 如果调用recvfrom时，恰好**没有**数据，阻塞IO会使进程阻塞，非阻塞IO会使CPU空转，都不能充分发挥CPU的作用。
   - 如果调用recvfrom时，恰好**有**数据，则用户进程可以直接进入第二阶段，读取并处理数据
 - 比如服务器端处理客户端Socket请求时，在单线程情况下，只能依次处理每一个socket，如果正在处理的socket恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有其他客户端socket都必须等待，性能自然会很差。


 - **文件描述符（File Descriptor）**：简称FD,是一个从0开始提增的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。
 - **IO多路复用**：利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。
<img width="784" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/dead7e70-a8ea-4202-9d9d-d2e1da0ff2e6">

 - 监听FD的方式、通知的方式又有多种实现，常见的有：
   - **select** 
   - **poll**
   - 上面两种是早期的方式，这两种方式只知道这么多FD中有一个或多个FD数据准备就绪，但是不知道是哪个FD，只能挨个询问。
   - **epoll**：这种方式知道哪个FD准备就绪。  
 - select流程（1.表示用户空间，2.表示内核空间）：
   - 1.1 创建一个fd集合fd_set,(大小为1024，初始值都未0)
   <img width="286" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/b73375be-e184-42a3-8abe-a66822d1219d">
   - 1.2 假如要监听fd=1,2,5,将对应的fd的值设置为1
   <img width="288" alt="image" src="https://github.com/hhhhby/Redis/assets/113978854/445fa60f-ad71-43d3-ba94-3b599a0abf36">



 - select模式存在的问题：
   - 需要将整个fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝会用户空间
   - select无法得知具体是哪个fd就绪，需要遍历整个fd_set
   - fd_set监听的fd数量不能超过1024
     
     


